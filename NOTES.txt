Design and Impl Notes for EasyPivot

A RelTab engine is:
   evalQuery : Query -> Promise<TableDataSource>

where TableData is an object providing a Schema and RowData.

Maybe TableDataSource is:
{
    schema :: Schema
    getRowCount :: Promise<Int>
    // given start row and count, fetch data for those rows
    getRowData :: Int, Int -> Promise<[[Any]]>  
}


OK, so if we pop up to AggTree what will we have:

A TreeDataSource is:
{
    schema :: Schema
    queryForPath :: Path -> Query
}
where Path = [Any]

Note the use of Query on rhs here instead of Promise<TableDataSource>.  
That should ensure that we can always apply additional operators to the original query to add (for example) another level of pivots.

Could, of course, be even lazier about this and also include a Column Range instead of just a Row range in the
argument to getRowData...

Presumably childrenForPath is equal to projection on first column of resulting table ( Actually we can probably leave this out entirely... )

----
How Will vpivot operator work?

Let's assume:
   - We have a TreeDataSource as input.
   - The schema has already had pivot column pre-pended

So let's consider the case where we pivot by [ "JobFamily", "Title" ]

to add one level of pivot:
   _inTree :: TreeDataSource
   pivotColumn = "Title"

t0.pivot("JobFamily").pivot("Title")

or

t0.pivot("Title").pivot("JobFamily")

probably the latter?

Or do they have anything to do with each other whatsoever?

Maybe this is just silly and we should just focus on 


==================
TODO:
   - Let's try to get basic AggTree VPivot operator working with TableDataSource as-is (currently fully reifies rowData)
   - Then we should be able to do a quick refactor to wrap rowData in Promises to make it lazier
   - Think about sort operation.  Clearly this happens at each level of the tree so its not just a leaf-level sort...

==================

What's the right model for dealing with ticking tables??
What's the connection between Signals / Streams and Promises ??
