Design and Impl Notes for EasyPivot

A RelTab engine is:
   evalQuery :: Query -> Promise<TableDataSource>

where TableData is an object providing a Schema and RowData.

Maybe TableDataSource is:
{
    schema :: Schema
    getRowCount :: Promise<Int>
    // given start row and count, fetch data for those rows
    getRowData :: Int, Int -> Promise<[[Any]]>  
}

AggTree gives us:

    vpivot :: function( rt : RelTab, baseQuery : Query, pivotColumns : [String] ): Promise<TreeDataSource>


Where TreeDataSource is:
{
    schema :: Schema
    queryForPath :: Path -> Query
}
where Path = [Any]

Note the use of Query on rhs here instead of Promise<TableDataSource>.  That should enable us to do things like walk down to a particular level of the pivot tree and then open the query determined by that level as a new window.  


Could, of course, be even lazier about this and also include a Column Range instead of just a Row range in the
argument to getRowData...

Presumably childrenForPath is equal to projection on first column of resulting table ( Actually we can probably leave this out entirely... )

We had previously considered trying to make vpivot operator take a single column identifier and map a TreeDataSource to a
TreeDataSource but it just seemed more complicated and not particularly useful so I've reverted back to having a one-shot
operator that takes an array of columns and offers a path -> table function in one shot.

==================
TODO:
   - Let's try to get basic AggTree VPivot operator working with TableDataSource as-is (currently fully reifies rowData)
   - Then we should be able to do a quick refactor to wrap rowData in Promises to make it lazier
   - Think about sort operation.  Clearly this happens at each level of the tree so its not just a leaf-level sort...

==================

What's the right model for dealing with ticking tables??
What's the connection between Signals / Streams and Promises ??
   We would invert our structure and think about what our pivot table will depend on in terms of data sources...
   On the source side I can envision an operator whose signature would be:
       baseTable :: String -> SF () TableData
   where argument is a (static) URL and TableData is roughly akin to a TableDataSource.
   But of course we need to address the nesting of Promises in original signature somehow...
   That means doing something like one of:
     - depending on host language laziness and return a getRowData function
     - returning a (Schema, SF () [[Any]] ) to be switched in to
     - just doing ( Schema, [[Any]] ) and living with it
   Each of these answers suck.  There must be a better way.  The challenge here is that, on the one hand, we want to be able to see asychrony and have laziness, but on the other hand we don't want too much "magic" that makes it difficult to reason
   about what's happening.

==================

Dealing with sorting in the pivot tree:

The right comparison is:

  cmp( r1, r2 ) {
    if( r1._depth==r2._depth ) {
      return cmp( r1[sortcol],r2[sortcol] );
    } else {
      cdepth = min( r1.depth, r2.depth );
      pr1 = parent( r1, cdepth );
      pr2 = parent( r2, cdepth );
      // Note: Either pr1==r1 or pr2==r2
      if( pr1==r2) 
        return -1; // pr1 ancestor-of r2
      if( pr2==r1) // pr2 ancestor-of r1
      return cmp( pr1, pr2 );
    }
  }

Either we need each row to keep track of its parents and have a way to efficiently get to a parent row,
OR
we need to each row to keep the values carried from all parents of sort keys

We probably just want to do the dynamic parent row lookup.
For better performance we could add _parent0, _parent1, ... columns to allow O(1) instead of O(log depth) lookup of parent id.  But the O(log depth) just won't be that expensive.

Now we need row ids, explicit _parent ids and efficient find() operation.
...and we're adding yet more functionality to the row store impl.
...and this has non-trivial architectural implications: We can't easily auto-generate row IDs in SQL; we may be able to do this on a case-by-case basis depending using proprietary extensions in some cases, but probably still need a fallback of doing this locally.  And that doesn't even address parent links at all.

Also not clear where / how to insert this in the query pipeline. So far we pass in a Query to the UI and work with that directly.

OK, we have something working....

But:  Right now we're doing this in epslick.  Yuck!  Sorting absolutely, positively does NOT belong in view code.  TODO: move to model.





